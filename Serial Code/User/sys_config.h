#ifndef __SYS_CONFIG_H_
#define __SYS_CONFIG_H_

#include "stm32f10x.h"
#include "./flash/W25Q16.h"
#include "./scan/GM65.h"
#include "./sys/sys.h"
#include "./scan/GM65.h"
#include "./usart/usart.h"
/**
 * //---------------------------------------------------------------//
 *                          串口流程指令说明
 * //---------------------------------------------------------------//
 * 指令格式
 * 例子： 12  34     01        09        01        01        0A      1F  2F
 *       [指令头] [指令设备] [指令位数] [指令类型] [指令内容] [指令校验] [指令尾]
 * 
 * 指令说明
 * 1. 指令头：作为指令的起始标志
 * 2. 指令位数：整个指令的字节数量=7+N N代表指令内容的数据量
 * 3. 指令类型：指令的类型
 * 4. 指令内容：指令包含的内容
 * 5. 指令校验：指令位数+指令类型+指令内容的和 如果超出FF 截取两位
 * 6. 指令尾：标志指令结束
 * 
 * 指令类型列表
 * 1. 01 代表改变阶段类型 内容有: 
 * [01] 进入清洗阶段
 * [02] 进入支付阶段
 * 其余阶段转换由下位机控制
 * 
 * 2. 02 代表完成填料，内容为00
 * 
 * 3. 03 代表配方选择 内容第一位为配方编号 第二位为糖量编号 
 * 
 * 4. 04 代表输入配方数据 和 编号
 */

//所有的指令都没有写校验 程序生成

/*
 * 指令16位 形式为A1 A2 A3 A4 字符长度 内容 两位校验码  B4 B3 B2 B1
 * 1. 等待阶段
 *    等待阶段主要是等待USART1的RXNE中断（安卓指令 清洗等命令也由安卓控制） UART5的RXNE中断（反馈系统的指令）
 *    优先级上USART1中断优先 反馈指令需要反馈系统一直发送以免漏掉
 *    阶段转换 有以下几种 指令16位
 *    1. 清洗阶段 上位机发送指令->
 *       A1 A2 A3 A4 01 00 00 01 B4 B3 B2 B1             
 *      清洗阶段（关闭所有中断 进入清洗流程）
 *      结束以后发回数据：
 *      A1 A2 A3 A4 01 01 00 02 B4 B3 B2 B1
 *      表示结束 程序返回等待阶段
 *    2. 缺料等待阶段 向上位机发送指令->
 *      A1 A2 A3 A4 01 02 00 03 B4 B3 B2 B1
 *        关闭除UART5和USART1以外的中断，等待UART5返回已经填料的信息，等待USART1返回可以开始的信息 UASRT1中断优先高
 *        都等待到后进入等待阶段 返回给上位机指令
 *      A1 A2 A3 A4 01 03 00 04 B4 B3 B2 B1
 *    3. 支付阶段  
 *      上位机发送指令
 *           A1 A2 A3 A4 01 02 00 03 B4 B3 B2 B1
 *      进入支付阶段
 * 2. 支付阶段
 *      关闭UART5中断 关闭UART1中断 打开UART4中断 打开TIM6中断，定时1S，跳60次 并开始计时
 *      两种情况 第一种TIM6计时结束仍然没有收到UART4中断，转入等待阶段，并且返回指令
 *      A1 A2 A3 A4 01 02 00 03 B4 B3 B2 B1
 *      第二种 收到了UART4信号，关闭TIM6中断，打开UART1中断,并且将UART4信息转发给USART1，等待UART1返回验证数据
 *      验证正确去工作阶段 验证不正确去等待阶段。
 * 3. 工作状态
 *      关闭UART5，UART4，USART1中断，关闭TIM6中断，打开TIM7中断 通过TIM7中断控制一下电机运转
*/

////校验失败指令，需要上位机再次发送上一条指令
//uint8_t ERROR_FEEDBACK[5]={0x12,0x34,0xFE,0x1F,0x2F};

////进入清洗阶段指令
//uint8_t WASH_START_ORDER[9]=           {0x12,0x34,0x01,0x09,0x01,0x01,0x00,0x1F,0x2F};
////回复已经进入清洗阶段
//uint8_t WASH_START_FEEDBACK[5]=        {0x12,0x34,0x00,0x1F,0x2F};
////回复已经完成清洗阶段 转至等待阶段
//uint8_t WASH_FINISH_FEEDBACK[5]=       {0x12,0x34,0x01,0x1F,0x2F};
////进入缺料状态的反馈
//uint8_t NEED_RELOAD_FEEDBACK[5]=       {0x12,0x34,0x02,0x1F,0x2F};
////填料完成指令(由运维人员操作上位机发出 表示已经加入料粉)
//uint8_t RELOAD_FINISH_ORDER[9]=        {0x12,0x34,0x01,0x09,0x02,0x00,0x00,0x1F,0x2F};
////回复填料完成的验证指令（确认填料完成）
//uint8_t RELOAD_SUCCESS_FEEDBACK[5]=    {0x12,0x34,0x03,0x1F,0x2F};
////回复填料完成的验证指令（监控系统发现填料并未完成）
//uint8_t RELOAD_FAIL_FEEDBACK[5]=       {0x12,0x34,0x04,0x1F,0x2F};

////支付阶段开始指令
//uint8_t PAYING_START_ORDER[9]=            {0x12,0x34,0x01,0x09,0x01,0x02,0x00,0x1F,0x2F};
////反馈 超时
//uint8_t PAYING_TIMEOUT_FEEDBACK[5]=    {0x12,0x34,0x05,0x1F,0x2F};
////反馈 成功
//uint8_t PAYING_SUCCESS_FEEDBACK[5]=    {0x12,0x34,0x06,0x1F,0x2F};
////二维码信息发送 第一行数据头 第二行第三行数据 第四行校验 第五行数据尾
//uint8_t PAYING_INFO_FEEDBACK[24]=      {0x12,0x34,\
//                                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
//                                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
//                                        0x00,0x00,\
//                                        0x1F,0x2F};

////校验完成后需要配方的编号 糖量 豆种 指令
//uint8_t WORKING_INFO_ORDER[10]=            {0x12,0x34,0x01,0x0A,0x03,0x00,0x00,0x00,0x1F,0x2F};
////工作阶段反馈 1. 磨豆机启动
//uint8_t CUT_MOTOR_FEEDBACK[5]=         {0x12,0x34,0x07,0x1F,0x2F};
////工作阶段反馈 2. 冲泡开始
//uint8_t RICH_START_FEEDBACK[5]=        {0x12,0x34,0x08,0x1F,0x2F};
////工作阶段反馈 3. 粉料加入
//uint8_t CONTENT_IN1_FEEDBACK[5]=       {0x12,0x34,0x09,0x1F,0x2F};
////工作阶段反馈 4. 辅料加入
//uint8_t COMTENT_IN2_FEEDBACK[5]=       {0x12,0x34,0x0A,0x1F,0x2F};
////工作阶段反馈 5. 完成
//uint8_t WORKING_SUCCESS_FEEDBACK[5]=   {0x12,0x34,0x0B,0x1F,0x2F};

#endif
